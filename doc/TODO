Читать файлы, шаблоны и конфиги через Sys::Mmap

man perlxstut, perlxs, perlapi, perlguts

Разобраться с Cache-Control и Expiresm добавить Last-Modified

template
view
et это все объекты, почемубы их не загружать через LoadObject('site',$site_name);

Class::DBI
Class::WhiteHole
WebDAV
Object::Registrar
Object::Realize::Later - возможно для базы данных
Persistence::Object ?

Использовать Template-Plugin-Page для страниц и соответсующий модуль для автозаполнения форм

my $some=db()->Select()->FetchAll();
#$some->FetchAll();

# Главный апач-хендлер инициализируется подобным образом и скрипта
# сайта, запускаемого через startup.pl

ему передаются модули:

share => new AWE2::Share
conf => new AWE2::Config($share)
log  => new AWE2::Log
uri  => new AWE2::Uri
accident => new AWE2::Accident($auth),

Подобный регистратор для модуля объекта исполнения

Должна быть возможность запускать этот метод из startup.pl

sub register {
   my $self = shift;
   my $session = new AWE2::Session();
   my $login = new AWE2::Login($session);
   my $auth  = new AWE2::Auth($login);
   my $cache = new AWE2::Cache; # применяется только для кеширования ответов
   $self->SetHandlers(
	login => $login,
        cache => $cache,
	auth  => $auth,
	db/oss=> new AWE2::Db($auth), # auth используется не только для проверки возможности
				      # запуска данного объекта и акции, но и на доступ к конкретным
				      # элементам базы данных. В таком случае буде сгенерирована
				      # ошибка доступа, котораядолжны быть выловленя и обработана
				      # через AWE2::Accident, которому соответственно передается
				      # этот модуль, чтобы из него можно было вытажить соответсвующие
				      # параметры, хотя их можно хранить в context::auth и тогда этот
				      # параметр указывать не надо.
	view  => new AWE2::View($cache),

	# Начиная отсюда все эти объекты устанавливаются автоматически и берутся с основного хендлера

	accident => new AWE2::Accident($auth), # Модуль необходим для отображения страниц,
	# Возникающих при ошибках, не соответсвии доступа и тп. Этот же модуль исопльзуется
        # ДЛя пдобных вещей основным хендлером
        log => new AWE2::Log,
	uri => new AWE2::Uri,
	share => new AWE2::Share,
   );

   # У каждого модуля-хендлера, что устанавливаются выше свои участки
   # в конфиге, соответсвующие именам модулей
   # Каждый модуль-хендлер при инициализации регистрирует свой namespace. Это имя используется
   # для обозначения группы в конфиге, контексте.

   # Резонно использовать не модули, а уже инстанцированные объекты.

   return $self->SUPER::init(@_);
}

# При запуске deinit действущего объекта запускаются деинитыдля всех хендлеров

# Объекты login, auth хранят данные в context через context::set context::get

sub CACHE_bar {
  return {param=>[qw(name surname age)]}, # по которым выходным значениями вычисляется ключ акции. Зависимость результата акции от этихи только этих параметров.
	  {age=>'123 days', # параметры кеширования (время и тд)
	   cache=>'html/action'};  # кешировать только ответ акции или даже вывод в html.
				   # Например. Если страница зависит не только от акции и входных
				   # параметров (например в ней выводится время), то кешируется
				   # только ответ акции.



  Хендлер просматривает эти параметры и если есть таокй результат в
  кеше, то акция даже не вызывается. Если нет, то вызывается и записывается в кеш после View

}

Sub ACTION_bar {
  my $self = shift;

  data({vasya=>123});

  view::output('somekey',$somedata);

  view::template('bar1');
  view::http_code(201);
  view::page_age('123 years');

  return $result,
	{template=>'bar2',
	 http_code=>201,
	 page_age=>'123 years',
 	};

}


В шаблон передается:

context
data
result

и параметры из view::output, в частности somekey. Эти параметры
переустанавливать нельзя. Очевидно, что contest, data и result
устанавливаются через эту процедуру.

Устанвливаются такие параметры как:

context::action
context::object
uri::actionPath


надо както указывать используемые в акции параметры, по ним вычислять
ключ и хранить кешированный ответ акции по этому ключу.


Надо придумать единую систему для обозначения всех входных и выходных
параметров. ПРименяться она будет в описании шаблона
(redirect:${uri:home}) и в описании параметров ключа для кеширования.

param:$key (параметры CGI)
uri:$key
cookie:??
result:$key

db:table_name:$key
или
objecet:table_name:$key применяются только для зависимости в парметрах ключа кеширования


Контекст - информация доступная при работе объекта и передаваемая в шаблон.
Возможно необходимо сделать взможность хранения всей информации в контексте, то есть:

context:auth
context:result
context:user
context:uri
context:object
context:action
context:template
context:view
context:error
context:language
context:cookie
context:subsystem
context:data

Есть подобная структура, называется system:, она единая для всех
чилдов сайта и находится в shared memory. Запись в нее через ->Lock


Apache::Storage
DBIx::Sequence
DBIx::Cursor?



$self->view()->AddFilter()

AddFilter свойственно только нужному view и он устанавливается с самого начала в акции